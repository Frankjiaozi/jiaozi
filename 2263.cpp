#include <stdio.h>
#include <math.h>  // 用于获取M_PI（π的精确值）
/*湖是圆形，半径为 R，0068 初始在圆心，小船速度为 V1，岸上速度为 V2；elnil 仅能在岸上移动，速度为 V2。
0068 的最优策略：先划到某个半径位置，使得自己绕湖的角速度超过 elnil，从而将 elnil 甩到湖的对面，再直线冲向岸边。
临界条件：当 0068 的划船速度 V1 足够大，或者 elnil 的岸上速度 V2 不够快时，0068 能逃脱。
关键推导：
当 0068 绕湖角速度等于 elnil 的角速度时，对应的临界半径为 r = (V1 * R) / V2。
0068 从临界半径 r 直线冲向岸边的时间，需小于 elnil 绕湖半圈（最远距离）的时间。
最终简化得到：0068 能逃脱的条件是 V2 < V1 * (π + 1)（π≈3.14159，π+1≈4.14159）*/

int main() {
    int R, V1, V2;
    // 处理多组测试用例，直到文件结束
    while (scanf("%d %d %d", &R, &V1, &V2) != EOF) {
        // 计算临界速度：V1*(π+1)
        double critical_speed = V1 * (M_PI + 1.0);
        // 判断V2是否小于临界速度，若是则能逃脱
        if (V2 < critical_speed) {
            printf("Yes\n");
        } else {
            printf("No\n");
        }
    }
    return 0;
}
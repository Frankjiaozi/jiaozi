#include <stdio.h>

// 全局变量定义
int ring[16] = {0};     // 存储素数环的数组，最大支持16个数字
int used[16] = {0};     // 标记数组，used[i-1]=1表示数字i已经被使用
int n;                  // 素数环的大小（数字个数）

/**
 * @brief 判断一个数是否为素数
 * 
 * @param x 要判断的整数
 * @return int 如果是素数返回1，否则返回0
 */
int isprime(int x)
{
    if(x <= 1)
    {
        return 0;
    }
    for(int i = 2; i * i <= x; i++)
    {
        if(x % i == 0)
        {
            return 0;
        }
    }
    return 1;
}

/**
 * @brief 深度优先搜索构建素数环
 * 
 * 该函数使用回溯算法尝试构建一个素数环。素数环要求：
 * 1. 使用数字1到n，每个数字恰好使用一次
 * 2. 相邻两个数字之和必须是素数
 * 3. 首尾两个数字之和也必须是素数
 * 
 * @param pos 当前要填充的位置（0到n-1）
 * 
 * 算法流程：
 * 1. 递归终止条件：当pos==n时，检查最后一个数字与第一个数字之和是否为素数
 * 2. 如果满足条件，输出当前构建的素数环
 * 3. 尝试在pos位置放置数字2到n
 * 4. 对每个未使用的数字i，检查ring[pos-1]+i是否为素数
 * 5. 如果满足条件，标记i为已使用，递归处理下一个位置
 * 6. 回溯时取消i的标记，继续尝试其他数字
 */
void dfs(int pos)
{
    // 递归终止条件：已经填充完所有位置
    if(pos == n)
    {
        // 检查最后一个数字与第一个数字之和是否为素数
        if(isprime(ring[pos-1] + ring[0]) == 1)
        {
            // 输出当前构建的素数环
            for(int i = 0; i < n; i++)
            {
                printf("%d", ring[i]);
                if(i != n-1)
                {
                    printf(" ");
                }
                if(i == n-1)
                {
                    printf("\n");
                }
            }
        }
        return;  // 重要：返回以避免继续执行下面的循环
    }
    
    // 尝试在pos位置放置数字2到n
    for(int i = 2; i <= n; i++)
    {
        // 检查数字i是否未使用，且与前一个数字之和为素数
        if(used[i-1] == 0 && isprime(ring[pos-1] + i) == 1)
        {
            used[i-1] = 1;    // 标记数字i为已使用
            ring[pos] = i;    // 在pos位置放置数字i
            dfs(pos + 1);     // 递归处理下一个位置
            used[i-1] = 0;    // 回溯：取消数字i的标记
        }
    }
}

int main()
{   
    scanf("%d", &n);    // 输入素数环的大小
    ring[0] = 1;        // 第一个位置固定为1
    used[0] = 1;        // 标记数字1为已使用
    dfs(1);             // 从位置1开始构建素数环
}